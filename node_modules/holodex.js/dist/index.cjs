var assert = require('assert');
var axios = require('axios');
var axiosRetry = require('axios-retry');
var querystring = require('querystring');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var axiosRetry__default = /*#__PURE__*/_interopDefaultLegacy(axiosRetry);
var querystring__default = /*#__PURE__*/_interopDefaultLegacy(querystring);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

class Channel {
  toRaw() {
    return this.raw;
  }
  /**
   * The unique ID of the channel.
   */


  get channelId() {
    return this.raw.id;
  }
  /**
   * The channel's name.
   */


  get name() {
    return this.raw.name;
  }
  /**
   * The channel's name in English, if it has one.
   */


  get englishName() {
    return this.raw.english_name;
  }
  /**
   * The type of the channel, either vtuber or subber.
   */


  get channelType() {
    return this.raw.type;
  }
  /**
   * The channel's organization. Mainly used for VTubers only.
   */


  get organization() {
    return this.raw.org;
  }
  /**
   * The channel's group/suborganization. Mainly used for VTubers only, that allows them to be sorted internally.
   */


  get group() {
    var _this$raw$group, _this$raw$suborg;

    return (_this$raw$group = this.raw.group) != null ? _this$raw$group : (_this$raw$suborg = this.raw.suborg) == null ? void 0 : _this$raw$suborg.substr(2);
  }

  get sortKey() {
    var _ref, _ref2, _this$raw$suborg2;

    return (_ref = (_ref2 = (_this$raw$suborg2 = this.raw.suborg) != null ? _this$raw$suborg2 : this.group) != null ? _ref2 : this.organization) != null ? _ref : this.name;
  }
  /**
   * The internal URL of the channel's profile picture.
   */


  get avatarUrl() {
    return this.raw.photo;
  }
  /**
   * The internal URL of the channel's channel banner.
   */


  get bannerUrl() {
    return this.raw.banner;
  }
  /**
   * The channel's Twitter handle, if they have one.
   */


  get twitterName() {
    return this.raw.twitter;
  }
  /**
   * The number of videos the channel has uploaded.
   */


  get videoCount() {
    return typeof this.raw.video_count === 'string' ? Number(this.raw.video_count) : this.raw.video_count;
  }
  /**
   * The estimated amount of subscribers the channel has.
   */


  get subscriberCount() {
    return typeof this.raw.subscriber_count === 'string' ? Number(this.raw.subscriber_count) : this.raw.subscriber_count;
  }
  /**
   * The total number of views the channel has.
   */


  get viewCount() {
    return typeof this.raw.view_count === 'string' ? Number(this.raw.view_count) : this.raw.view_count;
  }
  /**
   * The total number of clips associated with this channel. Mainly used for VTubers only.
   */


  get clipCount() {
    return typeof this.raw.clip_count === 'string' ? Number(this.raw.clip_count) : this.raw.clip_count;
  }
  /**
   * The language of the channel. Mainly used for Subbers only.
   */


  get language() {
    return this.raw.lang;
  }
  /**
   * The date this channel was created.
   */


  get createdAt() {
    return typeof this.raw.published_at === 'string' ? new Date(this.raw.published_at) : undefined;
  }
  /**
   * Whether or not the channel has been marked as inactive.
   */


  get isInactive() {
    return this.raw.inactive;
  }
  /**
   * The channel's description on YouTube.
   */


  get description() {
    return this.raw.description;
  }

  constructor(raw) {
    this.raw = void 0;
    this.raw = raw;
  }

}

class Comment {
  /**
   * The unique key associated with the comment.
   */
  get key() {
    return this.raw.comment_key;
  }
  /**
   * The video ID the comment is linked to.
   */


  get videoId() {
    return this.raw.video_id;
  }
  /**
   * The message content of the comment. Usually contains timestamps.
   */


  get content() {
    return this.raw.message;
  }

  constructor(raw) {
    this.raw = void 0;
    this.raw = raw;
  }

}

class Song {
  /**
   * The URL of the cover art.
   */
  get artUrl() {
    return this.raw.art;
  }
  /**
   * The name of the song.
   */


  get name() {
    return this.raw.name;
  }
  /**
   * The time in the associated {@link Video} where the song began.
   */


  get startTime() {
    return this.raw.start;
  }
  /**
   * The time in the associated {@link Video} where the song ended.
   */


  get endTime() {
    return this.raw.end;
  }
  /**
   * The unique ID of the song on iTunes, if it is on iTunes.
   */


  get iTunesId() {
    return this.raw.itunesid;
  }
  /**
   * The original artist who created/sang the song.
   */


  get artist() {
    return this.raw.original_artist;
  }

  constructor(raw) {
    this.raw = void 0;
    this.raw = raw;
  }

}

class Video {
  toRaw() {
    return this.raw;
  }
  /**
   * The unique ID of the video.
   */


  get videoId() {
    return this.raw.id;
  }
  /**
   * The video's title.
   */


  get title() {
    return this.raw.title;
  }
  /**
   * The type of video, whether it is a stream or a clip.
   */


  get videoType() {
    return this.raw.type;
  }
  /**
   * The internal topic ID of the video. Some videos, mostly clips, may not have a topic.
   */


  get topic() {
    return this.raw.topic_id;
  }
  /**
   * The date the video was published at.
   */


  get publishedAt() {
    return typeof this.raw.published_at === 'string' ? new Date(this.raw.published_at) : undefined;
  }
  /**
   * The date the video was made available. This takes on the first non-null value of {@link Video.publishedAt},
   * {@link Video.actualStart}, {@link Video.scheduledStart}, or {@link Video.actualEnd}.
   */


  get availableAt() {
    return typeof this.raw.available_at === 'string' ? new Date(this.raw.available_at) : undefined;
  }
  /**
   * The duration of the video.
   */


  get duration() {
    return this.raw.duration;
  }
  /**
   * The current status of the video on YouTube.
   */


  get status() {
    return this.raw.status;
  }
  /**
   * The date when the stream started. Used with {@link ExtraData.LiveInfo}
   */


  get scheduledStart() {
    return typeof this.raw.start_scheduled === 'string' ? new Date(this.raw.start_scheduled) : undefined;
  }
  /**
   * The date when the stream actually started. Used with {@link ExtraData.LiveInfo}
   */


  get actualStart() {
    return typeof this.raw.start_actual === 'string' ? new Date(this.raw.start_actual) : undefined;
  }
  /**
   * The date when the stream ended. Used with {@link ExtraData.LiveInfo}
   */


  get actualEnd() {
    return typeof this.raw.end_actual === 'string' ? new Date(this.raw.end_actual) : undefined;
  }
  /**
   * The number of people currently watching the stream. Used with {@link ExtraData.LiveInfo}
   */


  get liveViewers() {
    return this.raw.live_viewers;
  }
  /**
   * The description of the video. Used with {@link ExtraData.Description}
   */


  get description() {
    return this.raw.description;
  }
  /**
   * The number of tagged songs related to this video.
   */


  get songCount() {
    return this.raw.songcount;
  }
  /**
   * The channel ID the video creator.
   */


  get channelId() {
    var _this$raw$channel_id;

    return (_this$raw$channel_id = this.raw.channel_id) != null ? _this$raw$channel_id : this.channel.channelId;
  }
  /**
   * The {@link Channel} object of the video creator.
   */


  constructor(raw) {
    var _this$raw$comments$ma, _this$raw$comments, _this$raw$clips$map, _this$raw$clips, _this$raw$sources$map, _this$raw$sources, _this$raw$refers$map, _this$raw$refers, _this$raw$simulcasts$, _this$raw$simulcasts, _this$raw$mentions$ma, _this$raw$mentions, _this$raw$songs$map, _this$raw$songs;

    this.raw = void 0;
    this.channel = void 0;
    this.comments = void 0;
    this.clips = void 0;
    this.sources = void 0;
    this.refers = void 0;
    this.simulcasts = void 0;
    this.mentions = void 0;
    this.songs = void 0;
    this.raw = raw;
    this.channel = new Channel(this.raw.channel);
    this.comments = (_this$raw$comments$ma = (_this$raw$comments = this.raw.comments) == null ? void 0 : _this$raw$comments.map(comment => new Comment(comment))) != null ? _this$raw$comments$ma : [];
    this.clips = (_this$raw$clips$map = (_this$raw$clips = this.raw.clips) == null ? void 0 : _this$raw$clips.map(video => new Video(video))) != null ? _this$raw$clips$map : [];
    this.sources = (_this$raw$sources$map = (_this$raw$sources = this.raw.sources) == null ? void 0 : _this$raw$sources.map(video => new Video(video))) != null ? _this$raw$sources$map : [];
    this.refers = (_this$raw$refers$map = (_this$raw$refers = this.raw.refers) == null ? void 0 : _this$raw$refers.map(video => new Video(video))) != null ? _this$raw$refers$map : [];
    this.simulcasts = (_this$raw$simulcasts$ = (_this$raw$simulcasts = this.raw.simulcasts) == null ? void 0 : _this$raw$simulcasts.map(video => new Video(video))) != null ? _this$raw$simulcasts$ : [];
    this.mentions = (_this$raw$mentions$ma = (_this$raw$mentions = this.raw.mentions) == null ? void 0 : _this$raw$mentions.map(channel => new Channel(channel))) != null ? _this$raw$mentions$ma : [];
    this.songs = (_this$raw$songs$map = (_this$raw$songs = this.raw.songs) == null ? void 0 : _this$raw$songs.map(song => new Song(song))) != null ? _this$raw$songs$map : [];
  }

}

class HolodexApiClient {
  constructor(options) {
    var _options$url;

    this.httpClient = void 0;
    (_options$url = options.url) != null ? _options$url : options.url = 'https://holodex.net/api/v2';
    assert.strict.ok(typeof options.apiKey === 'string', 'apiKey not provided.');
    this.httpClient = axios__default['default'].create({
      baseURL: options.url,
      headers: {
        'X-APIKEY': options.apiKey
      }
    });
    axiosRetry__default['default'](this.httpClient, {
      retries: 3,
      retryDelay: axiosRetry__default['default'].exponentialDelay,
      retryCondition: error => axiosRetry__default['default'].isNetworkOrIdempotentRequestError(error) || error.code === 'ECONNABORTED',
      shouldResetTimeout: true
    });
  }
  /**
   * Retrieves a list of channels that match the given parameters.
   * @param params See {@link ChannelsParam}
   */


  async getChannels(params = {}) {
    var _params$limit, _params$offset, _params$order, _params$sort;

    (_params$limit = params.limit) != null ? _params$limit : params.limit = 25;
    (_params$offset = params.offset) != null ? _params$offset : params.offset = 0;
    (_params$order = params.order) != null ? _params$order : params.order = "asc"
    /* Ascending */
    ;
    (_params$sort = params.sort) != null ? _params$sort : params.sort = 'org';

    if (params.lang && Array.isArray(params.lang)) {
      params.lang = params.lang.join(',');
    }

    const q = querystring__default['default'].stringify(_extends({}, params, {
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const {
      data
    } = await this.httpClient.get(`/channels?${q}`);
    return data.map(channel => new Channel(channel));
  }
  /**
   * Retrieves a single channel.
   * @param channelId ID of the Youtube Channel that is being queried
   */


  async getChannel(channelId) {
    const {
      data
    } = await this.httpClient.get(`/channels/${channelId}`);
    return new Channel(data);
  }
  /**
   * A simplified endpoint for access channel specific data.
   * @param channelId ID of the Youtube Channel that is being queried
   * @param searchType The type of video resource to fetch. `clips` finds clip videos of a vtuber channel, `videos` finds the channelId channel's uploads, and `collabs` finds videos uploaded by other channels that mention this channelId
   * @param params See {@link ChannelVideosParam}
   */


  async getVideosByChannelId(channelId, searchType = "videos"
  /* Videos */
  , params = {}) {
    var _params$lang, _params$limit2, _params$offset2;

    (_params$lang = params.lang) != null ? _params$lang : params.lang = 'all';
    (_params$limit2 = params.limit) != null ? _params$limit2 : params.limit = 25;
    (_params$offset2 = params.offset) != null ? _params$offset2 : params.offset = 0;
    const q = querystring__default['default'].stringify(_extends({}, params, {
      include: Array.isArray(params.include) ? params.include.join(',') : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(',') : params.lang,
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const {
      data
    } = await this.httpClient.get(`/channels/${channelId}/${searchType}?${q}`);
    return data.map(video => new Video(video));
  }
  /**
   * Retrieves a video object.
   * @param videoId ID of a Youtube Video
   * @param includeComments if true then will reply with timestamp comments for this video
   * @param languages A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
   */


  async getVideo(videoId, includeComments = false, languages) {
    var _languages;

    (_languages = languages) != null ? _languages : languages = 'all';
    const params = {
      lang: Array.isArray(languages) ? languages.join(',') : languages
    };

    if (includeComments) {
      params.c = 1;
    }

    const q = querystring__default['default'].stringify(params);
    const {
      data
    } = await this.httpClient.get(`/videos/${videoId}?${q}`);
    return new Video(data);
  }
  /**
   * This endpoint is similar to the /live endpoint and usually replies much faster. It is more friendly in general. The cost to execute a lookup is significantly cheaper. It's unfortunately less customizable as a result.
   *
   * We recommends using this if you have a fixed set of channel IDs to look up status for.
   *
   * @param channelIds comma separated Youtube Channel IDs
   */


  async getLiveVideosByChannelId(channelIds) {
    const q = querystring__default['default'].stringify({
      channels: Array.isArray(channelIds) ? channelIds.join(',') : channelIds
    });
    const {
      data
    } = await this.httpClient.get(`/users/live?${q}`);
    return data.map(video => new Video(video));
  }
  /**
   * Retrieve all live streams for the given paramaters.
   *
   * This is somewhat similar to calling `getVideos`, but this endpoint imposes default values on the query parameters.
   *
   * @param params See {@link VideosParam}
   */


  async getLiveVideos(params = {}) {
    var _params$lang2, _params$offset3;

    (_params$lang2 = params.lang) != null ? _params$lang2 : params.lang = 'all';
    (_params$offset3 = params.offset) != null ? _params$offset3 : params.offset = 0;
    const q = querystring__default['default'].stringify(_extends({}, params, {
      include: Array.isArray(params.include) ? params.include.join(',') : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(',') : params.lang
    }));
    const {
      data
    } = await this.httpClient.get(`/live?${q}`);
    return data.map(video => new Video(video));
  }
  /**
   * Retrieve videos matching the given parameters.
   *
   * @param params See {@link VideosParam}
   */


  async getVideos(params = {}) {
    var _params$lang3, _params$limit3, _params$offset4, _params$order2, _params$sort2;

    (_params$lang3 = params.lang) != null ? _params$lang3 : params.lang = 'all';
    (_params$limit3 = params.limit) != null ? _params$limit3 : params.limit = 25;
    (_params$offset4 = params.offset) != null ? _params$offset4 : params.offset = 0;
    (_params$order2 = params.order) != null ? _params$order2 : params.order = "desc"
    /* Descending */
    ;
    (_params$sort2 = params.sort) != null ? _params$sort2 : params.sort = 'available_at';
    const q = querystring__default['default'].stringify(_extends({}, params, {
      include: Array.isArray(params.include) ? params.include.join(',') : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(',') : params.lang,
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const {
      data
    } = await this.httpClient.get(`/videos?${q}`);
    return data.map(video => new Video(video));
  }

}

exports.Channel = Channel;
exports.Comment = Comment;
exports.HolodexApiClient = HolodexApiClient;
exports.Song = Song;
exports.Video = Video;
//# sourceMappingURL=index.cjs.map
