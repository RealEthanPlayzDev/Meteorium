#!/usr/bin/env node
var yargs = require('yargs');
var chalk = require('chalk');
var assert = require('assert');
var axios = require('axios');
var axiosRetry = require('axios-retry');
var querystring = require('querystring');
var terminalLink = require('terminal-link');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var yargs__default = /*#__PURE__*/_interopDefaultLegacy(yargs);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var axiosRetry__default = /*#__PURE__*/_interopDefaultLegacy(axiosRetry);
var querystring__default = /*#__PURE__*/_interopDefaultLegacy(querystring);
var terminalLink__default = /*#__PURE__*/_interopDefaultLegacy(terminalLink);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

class Channel {
  toRaw() {
    return this.raw;
  }
  /**
   * The unique ID of the channel.
   */


  get channelId() {
    return this.raw.id;
  }
  /**
   * The channel's name.
   */


  get name() {
    return this.raw.name;
  }
  /**
   * The channel's name in English, if it has one.
   */


  get englishName() {
    return this.raw.english_name;
  }
  /**
   * The type of the channel, either vtuber or subber.
   */


  get channelType() {
    return this.raw.type;
  }
  /**
   * The channel's organization. Mainly used for VTubers only.
   */


  get organization() {
    return this.raw.org;
  }
  /**
   * The channel's group/suborganization. Mainly used for VTubers only, that allows them to be sorted internally.
   */


  get group() {
    var _this$raw$group, _this$raw$suborg;

    return (_this$raw$group = this.raw.group) != null ? _this$raw$group : (_this$raw$suborg = this.raw.suborg) == null ? void 0 : _this$raw$suborg.substr(2);
  }

  get sortKey() {
    var _ref, _ref2, _this$raw$suborg2;

    return (_ref = (_ref2 = (_this$raw$suborg2 = this.raw.suborg) != null ? _this$raw$suborg2 : this.group) != null ? _ref2 : this.organization) != null ? _ref : this.name;
  }
  /**
   * The internal URL of the channel's profile picture.
   */


  get avatarUrl() {
    return this.raw.photo;
  }
  /**
   * The internal URL of the channel's channel banner.
   */


  get bannerUrl() {
    return this.raw.banner;
  }
  /**
   * The channel's Twitter handle, if they have one.
   */


  get twitterName() {
    return this.raw.twitter;
  }
  /**
   * The number of videos the channel has uploaded.
   */


  get videoCount() {
    return typeof this.raw.video_count === 'string' ? Number(this.raw.video_count) : this.raw.video_count;
  }
  /**
   * The estimated amount of subscribers the channel has.
   */


  get subscriberCount() {
    return typeof this.raw.subscriber_count === 'string' ? Number(this.raw.subscriber_count) : this.raw.subscriber_count;
  }
  /**
   * The total number of views the channel has.
   */


  get viewCount() {
    return typeof this.raw.view_count === 'string' ? Number(this.raw.view_count) : this.raw.view_count;
  }
  /**
   * The total number of clips associated with this channel. Mainly used for VTubers only.
   */


  get clipCount() {
    return typeof this.raw.clip_count === 'string' ? Number(this.raw.clip_count) : this.raw.clip_count;
  }
  /**
   * The language of the channel. Mainly used for Subbers only.
   */


  get language() {
    return this.raw.lang;
  }
  /**
   * The date this channel was created.
   */


  get createdAt() {
    return typeof this.raw.published_at === 'string' ? new Date(this.raw.published_at) : undefined;
  }
  /**
   * Whether or not the channel has been marked as inactive.
   */


  get isInactive() {
    return this.raw.inactive;
  }
  /**
   * The channel's description on YouTube.
   */


  get description() {
    return this.raw.description;
  }

  constructor(raw) {
    this.raw = void 0;
    this.raw = raw;
  }

}

class Comment {
  /**
   * The unique key associated with the comment.
   */
  get key() {
    return this.raw.comment_key;
  }
  /**
   * The video ID the comment is linked to.
   */


  get videoId() {
    return this.raw.video_id;
  }
  /**
   * The message content of the comment. Usually contains timestamps.
   */


  get content() {
    return this.raw.message;
  }

  constructor(raw) {
    this.raw = void 0;
    this.raw = raw;
  }

}

class Song {
  /**
   * The URL of the cover art.
   */
  get artUrl() {
    return this.raw.art;
  }
  /**
   * The name of the song.
   */


  get name() {
    return this.raw.name;
  }
  /**
   * The time in the associated {@link Video} where the song began.
   */


  get startTime() {
    return this.raw.start;
  }
  /**
   * The time in the associated {@link Video} where the song ended.
   */


  get endTime() {
    return this.raw.end;
  }
  /**
   * The unique ID of the song on iTunes, if it is on iTunes.
   */


  get iTunesId() {
    return this.raw.itunesid;
  }
  /**
   * The original artist who created/sang the song.
   */


  get artist() {
    return this.raw.original_artist;
  }

  constructor(raw) {
    this.raw = void 0;
    this.raw = raw;
  }

}

class Video {
  toRaw() {
    return this.raw;
  }
  /**
   * The unique ID of the video.
   */


  get videoId() {
    return this.raw.id;
  }
  /**
   * The video's title.
   */


  get title() {
    return this.raw.title;
  }
  /**
   * The type of video, whether it is a stream or a clip.
   */


  get videoType() {
    return this.raw.type;
  }
  /**
   * The internal topic ID of the video. Some videos, mostly clips, may not have a topic.
   */


  get topic() {
    return this.raw.topic_id;
  }
  /**
   * The date the video was published at.
   */


  get publishedAt() {
    return typeof this.raw.published_at === 'string' ? new Date(this.raw.published_at) : undefined;
  }
  /**
   * The date the video was made available. This takes on the first non-null value of {@link Video.publishedAt},
   * {@link Video.actualStart}, {@link Video.scheduledStart}, or {@link Video.actualEnd}.
   */


  get availableAt() {
    return typeof this.raw.available_at === 'string' ? new Date(this.raw.available_at) : undefined;
  }
  /**
   * The duration of the video.
   */


  get duration() {
    return this.raw.duration;
  }
  /**
   * The current status of the video on YouTube.
   */


  get status() {
    return this.raw.status;
  }
  /**
   * The date when the stream started. Used with {@link ExtraData.LiveInfo}
   */


  get scheduledStart() {
    return typeof this.raw.start_scheduled === 'string' ? new Date(this.raw.start_scheduled) : undefined;
  }
  /**
   * The date when the stream actually started. Used with {@link ExtraData.LiveInfo}
   */


  get actualStart() {
    return typeof this.raw.start_actual === 'string' ? new Date(this.raw.start_actual) : undefined;
  }
  /**
   * The date when the stream ended. Used with {@link ExtraData.LiveInfo}
   */


  get actualEnd() {
    return typeof this.raw.end_actual === 'string' ? new Date(this.raw.end_actual) : undefined;
  }
  /**
   * The number of people currently watching the stream. Used with {@link ExtraData.LiveInfo}
   */


  get liveViewers() {
    return this.raw.live_viewers;
  }
  /**
   * The description of the video. Used with {@link ExtraData.Description}
   */


  get description() {
    return this.raw.description;
  }
  /**
   * The number of tagged songs related to this video.
   */


  get songCount() {
    return this.raw.songcount;
  }
  /**
   * The channel ID the video creator.
   */


  get channelId() {
    var _this$raw$channel_id;

    return (_this$raw$channel_id = this.raw.channel_id) != null ? _this$raw$channel_id : this.channel.channelId;
  }
  /**
   * The {@link Channel} object of the video creator.
   */


  constructor(raw) {
    var _this$raw$comments$ma, _this$raw$comments, _this$raw$clips$map, _this$raw$clips, _this$raw$sources$map, _this$raw$sources, _this$raw$refers$map, _this$raw$refers, _this$raw$simulcasts$, _this$raw$simulcasts, _this$raw$mentions$ma, _this$raw$mentions, _this$raw$songs$map, _this$raw$songs;

    this.raw = void 0;
    this.channel = void 0;
    this.comments = void 0;
    this.clips = void 0;
    this.sources = void 0;
    this.refers = void 0;
    this.simulcasts = void 0;
    this.mentions = void 0;
    this.songs = void 0;
    this.raw = raw;
    this.channel = new Channel(this.raw.channel);
    this.comments = (_this$raw$comments$ma = (_this$raw$comments = this.raw.comments) == null ? void 0 : _this$raw$comments.map(comment => new Comment(comment))) != null ? _this$raw$comments$ma : [];
    this.clips = (_this$raw$clips$map = (_this$raw$clips = this.raw.clips) == null ? void 0 : _this$raw$clips.map(video => new Video(video))) != null ? _this$raw$clips$map : [];
    this.sources = (_this$raw$sources$map = (_this$raw$sources = this.raw.sources) == null ? void 0 : _this$raw$sources.map(video => new Video(video))) != null ? _this$raw$sources$map : [];
    this.refers = (_this$raw$refers$map = (_this$raw$refers = this.raw.refers) == null ? void 0 : _this$raw$refers.map(video => new Video(video))) != null ? _this$raw$refers$map : [];
    this.simulcasts = (_this$raw$simulcasts$ = (_this$raw$simulcasts = this.raw.simulcasts) == null ? void 0 : _this$raw$simulcasts.map(video => new Video(video))) != null ? _this$raw$simulcasts$ : [];
    this.mentions = (_this$raw$mentions$ma = (_this$raw$mentions = this.raw.mentions) == null ? void 0 : _this$raw$mentions.map(channel => new Channel(channel))) != null ? _this$raw$mentions$ma : [];
    this.songs = (_this$raw$songs$map = (_this$raw$songs = this.raw.songs) == null ? void 0 : _this$raw$songs.map(song => new Song(song))) != null ? _this$raw$songs$map : [];
  }

}

class HolodexApiClient {
  constructor(options) {
    var _options$url;

    this.httpClient = void 0;
    (_options$url = options.url) != null ? _options$url : options.url = 'https://holodex.net/api/v2';
    assert.strict.ok(typeof options.apiKey === 'string', 'apiKey not provided.');
    this.httpClient = axios__default['default'].create({
      baseURL: options.url,
      headers: {
        'X-APIKEY': options.apiKey
      }
    });
    axiosRetry__default['default'](this.httpClient, {
      retries: 3,
      retryDelay: axiosRetry__default['default'].exponentialDelay,
      retryCondition: error => axiosRetry__default['default'].isNetworkOrIdempotentRequestError(error) || error.code === 'ECONNABORTED',
      shouldResetTimeout: true
    });
  }
  /**
   * Retrieves a list of channels that match the given parameters.
   * @param params See {@link ChannelsParam}
   */


  async getChannels(params = {}) {
    var _params$limit, _params$offset, _params$order, _params$sort;

    (_params$limit = params.limit) != null ? _params$limit : params.limit = 25;
    (_params$offset = params.offset) != null ? _params$offset : params.offset = 0;
    (_params$order = params.order) != null ? _params$order : params.order = "asc"
    /* Ascending */
    ;
    (_params$sort = params.sort) != null ? _params$sort : params.sort = 'org';

    if (params.lang && Array.isArray(params.lang)) {
      params.lang = params.lang.join(',');
    }

    const q = querystring__default['default'].stringify(_extends({}, params, {
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const {
      data
    } = await this.httpClient.get(`/channels?${q}`);
    return data.map(channel => new Channel(channel));
  }
  /**
   * Retrieves a single channel.
   * @param channelId ID of the Youtube Channel that is being queried
   */


  async getChannel(channelId) {
    const {
      data
    } = await this.httpClient.get(`/channels/${channelId}`);
    return new Channel(data);
  }
  /**
   * A simplified endpoint for access channel specific data.
   * @param channelId ID of the Youtube Channel that is being queried
   * @param searchType The type of video resource to fetch. `clips` finds clip videos of a vtuber channel, `videos` finds the channelId channel's uploads, and `collabs` finds videos uploaded by other channels that mention this channelId
   * @param params See {@link ChannelVideosParam}
   */


  async getVideosByChannelId(channelId, searchType = "videos"
  /* Videos */
  , params = {}) {
    var _params$lang, _params$limit2, _params$offset2;

    (_params$lang = params.lang) != null ? _params$lang : params.lang = 'all';
    (_params$limit2 = params.limit) != null ? _params$limit2 : params.limit = 25;
    (_params$offset2 = params.offset) != null ? _params$offset2 : params.offset = 0;
    const q = querystring__default['default'].stringify(_extends({}, params, {
      include: Array.isArray(params.include) ? params.include.join(',') : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(',') : params.lang,
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const {
      data
    } = await this.httpClient.get(`/channels/${channelId}/${searchType}?${q}`);
    return data.map(video => new Video(video));
  }
  /**
   * Retrieves a video object.
   * @param videoId ID of a Youtube Video
   * @param includeComments if true then will reply with timestamp comments for this video
   * @param languages A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
   */


  async getVideo(videoId, includeComments = false, languages) {
    var _languages;

    (_languages = languages) != null ? _languages : languages = 'all';
    const params = {
      lang: Array.isArray(languages) ? languages.join(',') : languages
    };

    if (includeComments) {
      params.c = 1;
    }

    const q = querystring__default['default'].stringify(params);
    const {
      data
    } = await this.httpClient.get(`/videos/${videoId}?${q}`);
    return new Video(data);
  }
  /**
   * This endpoint is similar to the /live endpoint and usually replies much faster. It is more friendly in general. The cost to execute a lookup is significantly cheaper. It's unfortunately less customizable as a result.
   *
   * We recommends using this if you have a fixed set of channel IDs to look up status for.
   *
   * @param channelIds comma separated Youtube Channel IDs
   */


  async getLiveVideosByChannelId(channelIds) {
    const q = querystring__default['default'].stringify({
      channels: Array.isArray(channelIds) ? channelIds.join(',') : channelIds
    });
    const {
      data
    } = await this.httpClient.get(`/users/live?${q}`);
    return data.map(video => new Video(video));
  }
  /**
   * Retrieve all live streams for the given paramaters.
   *
   * This is somewhat similar to calling `getVideos`, but this endpoint imposes default values on the query parameters.
   *
   * @param params See {@link VideosParam}
   */


  async getLiveVideos(params = {}) {
    var _params$lang2, _params$offset3;

    (_params$lang2 = params.lang) != null ? _params$lang2 : params.lang = 'all';
    (_params$offset3 = params.offset) != null ? _params$offset3 : params.offset = 0;
    const q = querystring__default['default'].stringify(_extends({}, params, {
      include: Array.isArray(params.include) ? params.include.join(',') : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(',') : params.lang
    }));
    const {
      data
    } = await this.httpClient.get(`/live?${q}`);
    return data.map(video => new Video(video));
  }
  /**
   * Retrieve videos matching the given parameters.
   *
   * @param params See {@link VideosParam}
   */


  async getVideos(params = {}) {
    var _params$lang3, _params$limit3, _params$offset4, _params$order2, _params$sort2;

    (_params$lang3 = params.lang) != null ? _params$lang3 : params.lang = 'all';
    (_params$limit3 = params.limit) != null ? _params$limit3 : params.limit = 25;
    (_params$offset4 = params.offset) != null ? _params$offset4 : params.offset = 0;
    (_params$order2 = params.order) != null ? _params$order2 : params.order = "desc"
    /* Descending */
    ;
    (_params$sort2 = params.sort) != null ? _params$sort2 : params.sort = 'available_at';
    const q = querystring__default['default'].stringify(_extends({}, params, {
      include: Array.isArray(params.include) ? params.include.join(',') : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(',') : params.lang,
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const {
      data
    } = await this.httpClient.get(`/videos?${q}`);
    return data.map(video => new Video(video));
  }

}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var dayjs_min = createCommonjsModule(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},D="en",v={};v[D]=M;var p=function(t){return t instanceof _},S=function(t,e,n){var r;if(!t)return D;if("string"==typeof t)v[t]&&(r=t),e&&(v[t]=e,r=t);else {var i=t.name;v[i]=t,r=i;}return !n&&r&&(D=r),r||!n&&D},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O},m.isValid=function(){return !(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var D=this.$locale().weekStart||0,v=(y<D?y+7:y)-D;return $(r?m-v:m+(6-v),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].substr(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,D=O.m(this,M);return D=(l={},l[c]=D/12,l[f]=D,l[h]=D/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?D:O.a(D)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return v[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),b=_.prototype;return w.prototype=b,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=v[D],w.Ls=v,w.p={},w}));
});

var relativeTime = createCommonjsModule(function (module, exports) {
!function(r,e){module.exports=e();}(commonjsGlobal,(function(){return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return "function"==typeof M?M(a):M.replace("%s",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)};}}));
});

/**
 * Derived from https://github.com/RiceCakess/Holodex
 *  MIT License
 *  Copyright (c) 2020 David Chen
 *
 * @see https://github.com/RiceCakess/Holodex/blob/8593a469593fbae45008270622e9b1bed785f47a/src/utils/consts.js#L25
 */
const ORGS = Object.freeze({
  all: 'All Vtubers',
  hololive: 'Hololive',
  nijisanji: 'Nijisanji',
  'kizuna-ai': 'Kizuna Ai Inc.',
  indie: 'Independents',
  vspo: 'VSpo',
  vshojo: 'VShojo',
  '774inc': '774inc',
  '.live': '.LIVE',
  noripro: 'Nori Pro',
  react: 'ReACT',
  voms: 'VOMS',
  kamitsubaki: 'KAMITSUBAKI',
  eilene: 'Eilene Family',
  'hoshimeguri-gakuen': 'Hoshimeguri Gakuen',
  'riot-music': 'Riot Music',
  propro: 'ProPro',
  wactor: 'WACTOR',
  'aogiri-highschool': 'Aogiri Highschool',
  masquerade: 'Masquerade',
  tsunderia: 'Tsunderia',
  'yuni-create': 'Yuni Create',
  'atelier-live': 'Atelier Live',
  prism: 'PRISM',
  'voice-ore': 'VOICE-ORE',
  vivid: 'ViViD',
  chukorara: 'Chukorara',
  'x-encount': "X enc'ount",
  marbl_s: 'Marbl_s',
  iridori: 'Iridori',
  'unreal-night-girls': 'Unreal Night Girls',
  'v-dimension.creators': 'V Dimension.Creators'
});

dayjs_min.extend(relativeTime);
function videoLink(videoId, title) {
  const ytURL = `https://www.youtube.com/watch?v=${videoId}`;
  return terminalLink__default['default'](chalk__default['default'].cyan.bold(title), ytURL);
}
function channelLink(channelId, title) {
  const ytURL = `https://www.youtube.com/channel/${channelId}`;
  return terminalLink__default['default'](chalk__default['default'].cyan.bold(title), ytURL);
}
function handlerFactory(processor = (...args) => args, printer = console.log) {
  return async argv => {
    const formatJSON = argv.json;
    const token = argv.token;
    const client = getClient(token || process.env.HOLODEX_APIKEY);
    const response = await Promise.resolve(processor({
      client,
      argv
    }));

    if (formatJSON) {
      if (Array.isArray(response)) {
        printAsJson(response.map(r => r.toRaw()));
      } else {
        printAsJson(response.toRaw());
      }

      return;
    }

    printer(response);
  };
}
function resolveOrg(scope) {
  return ORGS[scope] || ORGS['all'];
}
function getClient(apiKey) {
  return new HolodexApiClient({
    apiKey
  });
}
function fromNow(date) {
  return dayjs_min(date).fromNow();
}
function printAsJson(obj) {
  console.log(JSON.stringify(obj, null, 2));
}

const handler$2 = handlerFactory(async ({
  client,
  argv
}) => {
  const id = argv.id;
  const channel = await client.getChannel(id);
  return channel;
}, channel => {
  var _channel$description;

  console.log(channelLink(channel.channelId, channel.name));
  console.log(chalk__default['default'].gray((_channel$description = channel.description) == null ? void 0 : _channel$description.slice(0, 120), '...'));
});
const command$2 = {
  command: 'channel <id>',
  describe: 'Get channel info',
  builder: yargs => yargs.positional('id', {
    type: 'string',
    required: true,
    desc: 'Channel id'
  }),
  handler: handler$2
};

const handler$1 = handlerFactory(async ({
  client,
  argv
}) => {
  const org = resolveOrg(argv.scope);
  const videos = await client.getLiveVideos({
    org
  });
  return videos;
}, videos => {
  for (const video of videos) {
    console.log(videoLink(video.videoId, video.title));
    console.log(chalk__default['default'].gray(fromNow(video.scheduledStart)));
  }
});
const command$1 = {
  command: 'live [scope]',
  describe: 'Get live streams',
  builder: yargs => yargs.positional('scope', {
    type: 'string',
    default: 'all',
    desc: 'Search scope',
    choices: Object.keys(ORGS)
  }),
  handler: handler$1
};

const handler = handlerFactory(async ({
  client,
  argv
}) => {
  const id = argv.id;
  const video = await client.getVideo(id);
  return video;
}, video => {
  var _video$description;

  console.log(videoLink(video.videoId, video.title));
  console.log(chalk__default['default'].gray((_video$description = video.description) == null ? void 0 : _video$description.slice(0, 120), '...'));
});
const command = {
  command: 'video <id>',
  describe: 'Get video info',
  builder: yargs => yargs.positional('id', {
    type: 'string',
    required: true,
    desc: 'video id'
  }),
  handler
};

yargs__default['default'](process.argv.slice(2)).scriptName('holodex').help('help').alias('help', 'h').option('json', {
  alias: 'j',
  desc: 'Print JSON'
}).option('token', {
  type: 'string',
  alias: 't',
  desc: 'API Token'
}).command(command$1).command(command$2).command(command).demandCommand().argv;
//# sourceMappingURL=cli.cjs.map
