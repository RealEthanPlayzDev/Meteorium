// The command handler for Meteorium
// Written by RadiatedExodus (ItzEthanPlayz_YT/RealEthanPlayzDev)

const fs = require("fs");
const path = require("path");
const { Collection } = require('discord.js');
const { REST } = require('@discordjs/rest');
const { Routes } = require('discord-api-types/v9');
const GuildSettingSchema = require("../schemas/GuildSettingSchema");
const MeteoriumEmbed = require("./MeteoriumEmbed");

class MeteoriumCommandHandler {
    constructor(client, prefix, applicationId, token) {
        this.client = client;
        this.prefix = prefix;
        this.applicationId = applicationId;
        this.REST = new REST({ version: '9' }).setToken(token);
        this.parsedCommands = new Collection();
        this.interactionDeployCommands = [];
        this.disabledCommandCache = {};
        this.disabledCommandCategoryCache = {};
    }

    ParseCommands(targetDir = "../commands") {
        const files = fs.readdirSync(path.join(__dirname, targetDir)); //.filter(file => file.endsWith('.js'));
        for (const file of files) {
            const fInfo = fs.lstatSync(path.join(__dirname, targetDir, file));
            if (fInfo.isDirectory()) {
                this.ParseCommands(path.join(targetDir, file));
            } else {
                try {
                    const command = require(path.join(__dirname, targetDir, file));
                    this.parsedCommands.set(command.name, command);
                    this.interactionDeployCommands.push(command.interactionData.toJSON());
                } catch(err) {
                    console.error(`MeteoriumCommandHandler: error occured while parsing command file: ${path.join(__dirname, targetDir, file)}\n${err.stack}`);
                }
            }
        }
    }

    async DeployCommandInteraction(GuildId) {
        try {
            console.log(`MeteoriumCommandHandler: Deploying interaction for guildId ${GuildId}`);
            await this.REST.put(Routes.applicationGuildCommands(this.applicationId, GuildId), { body: this.interactionDeployCommands });
            console.log(`MeteoriumCommandHandler: Interaction deployed for guildId ${GuildId}`);
        } catch (err) {
            console.error(`MeteoriumCommandHandler: Error occured when deploying command interaction for guild ${GuildId}, \n${err.stack}`);
        }
    }

    async DeployGlobalCommandInteraction() {
        try {
            console.log(`MeteoriumCommandHandler: Deploying global interaction`);
            await this.REST.put(Routes.applicationCommands(this.applicationId), { body: this.interactionDeployCommands });
            console.log(`MeteoriumCommandHandler: Global interaction deployed successfully.`);
        } catch (err) {
            console.error(`MeteoriumCommandHandler: Error occured when deploying global command interaction, \n${err.stack}`);
        }
    }

    async HandleCommandInteraction(interaction) {
        try {
            if (!interaction.isCommand()) return;
            const targetCommand = this.parsedCommands.get(interaction.commandName);
            if (!targetCommand) return;
            if (this.disabledCommandCache[interaction.guildId] && this.disabledCommandCache[interaction.guildId][interaction.commandName]) {
                await interaction.reply({ embeds: [
                    new MeteoriumEmbed("Cannot run command", "This command has been disabled by a administrator for this server!", "FF0000")
                ]});
                return;
            }

            try {
                await targetCommand.execute(interaction, this.client);
            } catch(err) {
                console.error(`MeteoriumCommandHandler: error occured when handling command:\n${err.stack}`);
                const errEmbed = new MeteoriumEmbed("An error occured when running the command!", String(err), "FF0000").addFields({
                        name: "Note",
                        value: "This error is generated by ``MeteoriumCommandHandler``, coming from the command handler function"
                    });
                if (interaction.deferred) {
                    await interaction.editReply({ embeds: [errEmbed] });
                } else {
                    await interaction.reply({ embeds: [errEmbed] });
                }
            }
        } catch(err) {
            console.error(`MeteoriumCommandHandler: HandleCommandInteraction failed:\n${err.stack}`);
        }
    }

    async DeleteRegisteredSlashCommands(guildId) {
        this.client.guilds.fetch(guildId)?.commands?.cache?.forEach(async (command) => {
            await command.delete();
            console.log(`Deleted slash command ${command.name} (${command.id}) for guild ${guildId}`);
        })
        return true;
    }

    async DeleteRegisteredGlobalSlashCommands() {
        (await this.client.application.fetch()).commands.cache.forEach(async (command) => {
            await command.delete();
            console.log(`Deleted global slash command ${command.name} (${command.id})`);
        });
        return true;
    }

    CreateNewGuildSettingSchema(id, enforcesayinexecutor=false, disabledcommands={}, disabledcommandcategories={}, muteroleid="") {
        if (!id) { throw new Error("id not specified") }
        return new GuildSettingSchema({
            GuildId: id,
            EnforceSayinExecutor: enforcesayinexecutor,
            DisabledCommands: disabledcommands,
            DisabledCommandCategories: disabledcommandcategories,
            MuteRoleId: muteroleid
        });

    }

    async SaveGuildSettingSchema(guildsettingschema) { guildsettingschema.save().then(() => { console.log("Successfully registered schema for guild "+guild.id) }).catch(() => { this.SaveGuildSettingSchema(guildsettingschema) }) }

    async UpdateDisabledCommandCache(guildId) {
        if (!guildId) { throw new Error("MeteoriumCommandHandler: no guildId specified for UpdateDisabledCommandCache") }
        const guildSchema = await GuildSettingSchema.findOne({ GuildId: String(guildId) })
        if (guildSchema) {
            try {
                console.log(`MeteoriumCommandHandler: Updating guild disabled commands cache for GuildId ${guildId}`);
                this.disabledCommandCache[String(guildId)] = guildSchema.DisabledCommands;
                this.disabledCommandCategoryCache[String(guildId)] = guildSchema.DisabledCommandCategories;
            } catch(_) {}
        } else {
            console.warn(`MeteoriumCommandHandler: Guild ${guildId} doesn't exist on database? Creating new entry`);
            const newGuildSettingSchema = this.CreateNewGuildSettingSchema(guildId);
            this.SaveGuildSettingSchema(newGuildSettingSchema);
            this.UpdateDisabledCommandCache(guildId);
        }
    }
}

module.exports = MeteoriumCommandHandler;
